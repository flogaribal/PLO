<p align="center">
    <a href="#installation">Installation</a> •
    <a href="#how-to-use-chatette">How to use <i>Chatette</i>?</a>
</p>

*Chatette* is a Python package intended to developers of chatbots and other NLP tasks. This script is able to generate a large number of examples from a smaller description of their contents, i.e. templates, and this, in a completely custom way. Its primary objective is to produce example sentences for Rasa NLU.

## Installation
To run *Chatette*, you will need to have [Python](https://www.python.org/) installed.
*Chatette* works with both Python 2.7 and 3.x (>= 3.3).

*Chatette* is available on [PyPI](https://pypi.org/project/chatette), and can thus be installed using `pip`:
```sh
pip install chatette
```


## How to use *Chatette*?

### Input data


The data that *Chatette* uses and generates is loaded from and saved to files. We thus have:
- The **input file(s)** containing the templates that will be parsed and interpreted by Chatette.


#### Syntax of the template files

A template file contains a set of unit declarations, which are themselves sets of generation rules (also called *templates*).

Each line of the file can be one of 4 types:
1. **Empty lines and comments**: empty lines contain no characters; comment lines start with a double slash `//`. Both can be indented as you wish. Those lines will be ignored by the parser. Any string that follows a (unescaped) `//` will actually be ignored.
2. **Unit declaration initiator**: they are unindented lines starting with a special character (`%`, `@` or `~` depending on the type of unit that is being declared). The special character is followed by a set of unicode characters surrounded by square brackets (`[` and `]`) and in some cases followed by another string surrounded by parentheses (`(` and `)`).
3. **Unit declaration content**: those lines are the content of a unit declaration (which may be several lines long), and must be indented in a coherent way, i.e. all the contents of a declaration must be indented in the same way. Each of those line describe a generation rule for the declared unit, which we will call "rule" or "template".
4. **Inclusion of another file**: they tell the parser to include a certain file in place of this line. They begin with a pipe symbol `|` (not indented) directly followed by the file path (relative to the file which the script is executed on, that is, the "master" file).

A template file thus conforms to the following skeleton:
```
// comment
%[DECLARATION1](something)
   RULE1
   RULE2

@[DECLARATION2]
  RULE1
  RULE2 // comment
  RULE3
~[DECLARATION3] //comment
   RULE1
```

##### Generation rules
The lines marked as "rules" in the skeleton above are placeholders for what we call *generation rules*, that is, templates to follow in order to generate a string.
A rule is a sequence of parts called *sub-rules* which are able to generate certain strings. The string generated by the rule is then simply the concatenation of those strings. Sub-rules are separated by whitespaces or special characters (`~`, `@`, `%`, `[` or `]`).

Here is an exhaustive list of the types of sub-rules that exist and what they do upon generation:
- a **word** is a simple word, which will generate itself.
- a **group of words** is a sequence of words surrounded by square brackets (`[` and `]`). It will generate the sequence of words that it contains in the same order as it is specified. It is possible to add modifiers (described below) to change the generation behavior of a word group.
- a **unit reference** is done by writing the special character for the type of unit referenced, and then the unit's name surrounded by brackets (and possibly modifiers within the brackets as well). Upon generation, they will look for the unit declaration and make it generate a string (see below).
- a **choice** is made of different sequences of sub-rules separated by slashes `/`, the whole surrounded by curly braces `{` and `}`. It tells the generator to choose one of the rules within the choice as the generated string. It is forbidden to use a choice within a choice.

Here are examples of such sub-rules and what they could generate:

Sub-rule type | Sub-rule      | Possible generated string(s)
--------------|---------------|------------------------------
Word          | `test`        | `test`
Word group    | `[other test]`| `other test`
Unit reference| `~[alias]`    | *Depends on the unit declaration labelled `alias`*
Choice        | `{choice1/choice two/[third choice]/longer choice [very long]}` | `choice1`, `choice two`, `third choice` or `longer choice very long`


##### Units
A unit is a set of generation rules which can be used in other rules by referring to them. Upon generation (i.e. when the generator asks a unit declaration to generate a string), a rule is chosen at random inside its set of rules and generates the string.

To be able to refer to a unit, it must have been defined somewhere in the template file(s).
A unit definition is made of 2 parts:
- a declaration, on one line
- a set of rules, on one or several lines (cf. above)

The declaration line contains information about the unit that is being defined.
The mandatory information in the declarations is:
- the type of unit being declared, denoted with a special character the line starts with,
- a name to refer to this particular unit, which is a string containing any characters (including whitespaces) except special characters (unless they are escaped using a backslash `\`).

Here are all the characters that should be escaped if you want to use them in a unit identifier (i.e. use `\;` instead of `,`): `?`, `;`, `/`, `//`, `#`, `$`, `&`, `[` and `]`.

The optional information and how to declare it will be discussed below.

##### Types of units
##### Alias
An alias simply represents a set of generation rules, which can be used within other rules. An alias could for example be a list of synonyms that can be used interchangeably in generated examples.

Here is an example of a simple alias definition:
```
~[Time]
   demain
   ce weekend
   le mois prochain
   cette semaine
```

Referring to this example inside another rule would thus for instance be done the following way:
```
Je veux voyager ~[Time]
```
where `Je`, `veux`, and `voyager` are each sub-rules of type *word* and `~[Time]` is an alias reference.
This specific example would generate `Je veux voyager demain` 25% of the time, `Je veux voyager ce weekend` 25% of the time, `Je veux voyager le mois prochain` 25% of the time and `Je veux voyager cette semaine` the rest of the time.

##### Intent
Intents are entry points of the generator in the template file, which means there must be at least one intent in the template file(s) in order to have a non-empty example generation. If you refer to one of them in a rule, they will behave as aliases.

Defining an intent comes down to saying:
> I want *Chatette* to generate *X* examples denoted as having the intent *Y*.

After an intent declaration, we can thus give the number of examples that should be generated. If no number is given, *Chatette* will generate all possible examples.

Here is an example of a simple intent definition:
```
%[greeting](2)
   hello
   hi
   Hi!
```

##### Slot
A slot in a generation rule represents what *Rasa NLU* calls an entity, i.e. a finite set of values for a particular variable for which different values mean different things.
We will sometimes refer to slots as entities.

Here is an example of a simple slot definition.
```
@[destination]
   Madrid
   Toulouse
   Paris
   Sydney
```

Referring to this slot in other rules would for instance be done as follows:
```
Je veux aller à  @[destination].
```
which will generate `Je veux aller à Madrid.` 25% of the time, `Je veux aller à Toulouse.` 25% of the time, `Je veux aller à Paris.` 25% of the time and `Je veux aller à Sydney.` the rest of the time. In the output file, all the parts of the generated sentences that were generated by a reference to this slot will be marked as belonging to an entity called `destination`.

#### Modifiers
For both unit declarations and sub-rules, we can add modifiers to change the behavior of the generator when it encounters it. The generation behavior is changed for the current sub-rule/unit declaration only. Note also that simple words cannot take any modifiers.

##### Usable with both declarations and references
- **Case generation**: this tells the generator to randomly choose between a leading uppercase or lowercase letter for the first letter of the unit or reference on generation. This modifier is denoted by an ampersand `&` placed right after the opening bracket `[` (or `{` for choices) in unit declaration initiators or sub-rules.

  For example, `[&hello]` will generate `hello` 50% of the time and `Hello` the rest of the time. 
##### Usable only with sub-rules
- **Random generation**: adding a question mark `?` right before the closing bracket `]` (or `}` for choices) of a sub-rule tells the generator to randomly decide whether it should ignore this sub-rule or not, and thus if it should generate a string or rather nothing. Except for choices, you can give an identifier for this random generation right after the question mark; every sub-rule that has this identifier for its random generation will be generated together or will not be generated at all (rather than some of them being generated and other not).

  For example,  the rule `hey [you?]` will generate `hey` 50% of the time and `hey you` the rest of time. The choice `{hello/hi}`  will generate `hello` 50 % of the time and `hi` the rest of the time. 

##### Usable only with declarations
- **Variation naming**: adding a hashtag followed by a certain name after the unit identifier tells the parser that you are making a flavor (or variation) of a unit. This unit variation can be referenced in rules as a normal unit, but you can also reference the unit without flavor, which will refer to all the variations of that unit. It is usually done to make a singular and a plural flavor of the same alias, and use the unit without flavor in places where singular or plural doesn't matter.

  For example, if the following aliases are defined:
  ```
  ~[alias#singular]
    alias
  ~[alias#plural]
    aliases
  ```
  the sub-rule `~[alias#singular]` will generate `alias`, `~[alias#plural]` generates `aliases` and `~[alias]` will generate `alias` 50% of the time and `aliases` the rest of the time.

# *Chatette* execution
To run *Chatette* on a template file, simply run the following command:
```sh
python -m chatette <path-to-template-file>
```
The generated examples will be put in a newly created file in `output/train/output.json` (or several files in the same folder if the output is really large). If you want the output to be put somewhere else, run the following command:
```sh
python -m chatette <path-to-template-file> -o <path-to-output-directory>
```


### Output data


- The **output file**, a *JSON* file containing data that can be directly fed to *Rasa NLU*. More about the training format will be found on the file explaining the Rasa NLU training format.